import copy

"""
We need to programm a Dijkstra algo:
 1. Mark all nodes unvisted: unvisted set
 2. Starting node: current node; init a distance dict with tentative
    distances between starting node and other nodes (tent. dist: inf)
 3. Calculate distance to *all neigbhours* of current node. Update
    tentaive distance if smaller.
 4. Mark current node as visited, remove from unvisited set.
 5. Break if destination node is in visited set or all nodes in
    unvisited set are inf.
 6. pop node from univisted with smallest distance.

In our example, the nodes are states of the grid and the neighbours
are generated by all allowed moves from a distinct situation.
This makes it necessary to have an unique hash for a given state of the 
grid to use as node name. Also, a functionality to get all allowed moves
from a state of the grid. 
Not all nodes are known from the beginning, so neighbours discovered
in step 3 will be added to unvisited set and tentative distance dict.
"""


class Node(object):
    char_to_num = {".": 0, "A": 1, "B": 10, "C": 100, "D": 1000}
    num_to_char = {v: k for k, v in char_to_num.items()}

    def __init__(self, gallery, rooms):
        self.gallery = gallery
        self.rooms = rooms

    @classmethod
    def from_hash(cls, string):
        gallery = []
        for item in string[:11]:
            gallery.append(Node.char_to_num.get(item))
        rooms = [[], [], [], []]
        for i, item in enumerate(string[12::2]):
            rooms[i % 4].append(Node.char_to_num.get(item))

        return cls(gallery, rooms)

    @staticmethod
    def from_file(filepath):
        with open(filepath, "r") as f:
            string = f.readline()

        return Node.from_hash(string)

    def hash(self):
        this_hash = ""
        for item in self.gallery:
            this_hash += Node.num_to_char.get(item)

        for r1, r2, r3, r4 in zip(*self.rooms):
            r1, r2, r3, r4 = map(lambda x: Node.num_to_char.get(x), (r1, r2, r3, r4))
            this_hash += f"#{r1}#{r2}#{r3}#{r4}"
        this_hash += "#"

        return this_hash

    def moves(self):
        # Amphipods can move out of rooms into other rooms if it's their
        # final room and no 'wrong' amphipods are in there. They can move
        # in the gallery otherwise.
        # If amphipods are in the gallery, they can only move into
        # their room and only if there are no 'wrong' amphipods there.

        self._move_gallery()
        self._move_room()

    def _move_room(self):
        for room_nr, room in enumerate(self.rooms):
            # Check if room is already in desired state
            if all(len(str(room_item)) == (room_nr + 1) for room_item in room):
                continue
            # Find item to move (room_pos).
            for room_pos, room_item in enumerate(room):
                if room_item > 0:
                    break
            # Move to room if possible: calculate new room position,
            # Check if gallery is free, move and calc cost
            # # # r1 # r2 # r3 # r4 # #
            # 0 1 2  3 4  5 6  7 8  9 10
            gallery_pos = 2 * (room_nr + 1)
            desired_room = len(str(room_item)) - 1
            desired_room_galery_pos = 2 * (desired_room + 1)
            if sum(self.gallery[gallery_pos : desired_room_galery_pos + 1]) < 1:
                # move to that room w. yield statement
                # @ToDo check if desired room is empty or only inhabited by
                # corret amphipods
                if any(
                    len(str(room_item)) == (desired_room + 1)
                    for room_item in self.rooms[desired_room]
                ):
                    break
                # Tentative, refactor from _move_gallery: Find new position (first empty space)
                for d_room_pos, d_room_item in enumerate(self.rooms[desired_room]):
                    if d_room_item > 0:
                        d_room_pos -= 1
                        break

            # Move to gallery position: enumerate over all viable
            # positions [0,1,3,5,7,9,10]

    def _move_gallery(self):
        for pos, item in enumerate(self.gallery):
            if item == 0:
                continue
            desired_room = len(str(item)) - 1
            # Room occupied by wrong amphipod
            if not all(
                True if room_item in [item, 0] else False
                for room_item in self.rooms[desired_room]
            ):
                continue
            move_to = 2 * (desired_room + 1)
            direction = int((move_to - pos) / abs(pos - move_to))
            # Other amphipods on the way
            if sum(self.gallery[pos + direction : move_to + direction : direction]) > 0:
                continue
            # Find new position (first empty space)
            for room_pos, room_item in enumerate(self.rooms[desired_room]):
                if room_item > 0:
                    room_pos -= 1
                    break
            # Switch positions and yield new Node. Calculate movements
            rooms = copy.deepcopy(self.rooms)
            rooms[desired_room][room_pos] = item
            gallery = copy.deepcopy(self.gallery)
            gallery[pos] = 0
            cost = (abs(move_to - pos) + room_pos + 1) * item

            yield Node(gallery, rooms), cost
